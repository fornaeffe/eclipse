<!DOCTYPE html>
<html>
	<head>
		<title>Eclipse simulator</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<canvas id="myCanvas">
		  <p>This browser doesn't support canvas.</p>
		</canvas>
		<div>
			Terra:
			<input type="range" min="0" max="360" value="0" class="slider" id="earth_theta">
			Luna:
			<input type="range" min="0" max="360" value="0" class="slider" id="moon_theta">
			Esagerazione tilt:
			<input type="range" min="1" max="5" value="3" class="slider" id="moon_tilt">
		</div>
		<div>
			Superficie dei pianeti da https://github.com/marshallmurphy/solar-system-threejs
		</div>
		<script type="module">
			// Parameters
			const earthOrbitRadius = 10;
			const moonOrbitRadius = 3;
			const sunRadius = 1.5;
			const earthRadius = 0.5;
			const moonRadius = 0.3;
			
			// Import three.js
			// Find the latest version by visiting https://unpkg.com/three. The URL will
			// redirect to the newest stable release.
			import * as THREE from 'https://unpkg.com/three@0.122.0/build/three.module.js';
			import { OrbitControls } from 'https://unpkg.com/three@0.122.0/examples/jsm/controls/OrbitControls.js';
			
			// Links to page elements
			const canvas = document.getElementById('myCanvas');
			const earth_thetaSlider = document.getElementById("earth_theta");
			const moon_thetaSlider = document.getElementById("moon_theta");
			const moon_tiltSlider = document.getElementById("moon_tilt");
			
			
			// Setup renderer
			const renderer = new THREE.WebGLRenderer({canvas: canvas, alpha: true});
			const width = window.innerWidth;
			const height = window.innerHeight * 0.9;
			const aspect_ratio = width / height;
			renderer.setSize( width, height );
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setClearColor("#121212", 1);
			renderer.shadowMap.enabled = true;
			
			// CAMERA
			const camera = new THREE.OrthographicCamera( - 12 * aspect_ratio, 12 * aspect_ratio, 12, -12, 1, 1000 );
			camera.position.set(0, earthOrbitRadius * 3, 0);
			
			// ORBIT CONTROLS
			const controls = new OrbitControls(camera, renderer.domElement);
			controls.enablePan = false;
			
			// SCENE
			const scene = new THREE.Scene();
			
			// TEXTURES
			const loader = new THREE.TextureLoader();
			const sunTexture = loader.load("assets/sun.jpg");
			const earthTexture = loader.load("assets/earth.jpg");
			const moonTexture = loader.load("assets/moon.jpg");
			
			// MATERIALS
			const sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture });
			const earthMaterial = new THREE.MeshStandardMaterial({ map: earthTexture });
			const moonMaterial = new THREE.MeshStandardMaterial({ map: moonTexture });
			
			const orbitMaterial = new THREE.LineBasicMaterial( { color : 0xff0000 } );
			
			// GEOMETRY
			
			// Planets
			const geometry = new THREE.SphereGeometry(1, 32, 16);
			
			// Orbits
			const orbit = new THREE.EllipseCurve(
				0,  0,            // ax, aY
				1, 1,           // xRadius, yRadius
				0,  2 * Math.PI,  // aStartAngle, aEndAngle
				false,            // aClockwise
				0                 // aRotation
			);
			const points = orbit.getPoints( 50 );
			const orbitGeometry = new THREE.BufferGeometry().setFromPoints( points );
			
			// MESHES
			
			// Sun
			const sunMesh = new THREE.Mesh(geometry, sunMaterial);
			sunMesh.position.set(0, 0, 0);
			sunMesh.scale.setScalar(sunRadius);
			scene.add(sunMesh);
			
			// Earth
			const earthGroup = new THREE.Group();		// create new Group
			earthGroup.rotation.set = new THREE.Euler();
			const earthMesh = new THREE.Mesh(geometry, earthMaterial);
			earthMesh.position.set(earthOrbitRadius, 0, 0);
			earthMesh.scale.setScalar(earthRadius);
			earthMesh.castShadow = true;
			earthMesh.receiveShadow = true;
			earthGroup.add(earthMesh);
			
			// Earth orbit	
			const earthOrbit = new THREE.Line( orbitGeometry, orbitMaterial );
			earthOrbit.rotation.x = Math.PI / 2;
			earthOrbit.scale.setScalar(earthOrbitRadius);
			earthGroup.add(earthOrbit);
			
			/*
			// Lighting
			for (let i = 0; i < 4; i ++) {
				const spotLight = new THREE.SpotLight( 0xffffff );
				spotLight.position.set(0, Math.sin(i * Math.PI / 2), Math.cos(i * Math.PI / 2));
				spotLight.target = earthMesh;
				spotLight.castShadow = true;
				earthGroup.add(spotLight);
			}
			*/
			
			scene.add(earthGroup);
			
			// Moon
			const moonMainGroup = new THREE.Group();
			moonMainGroup.rotation.set = new THREE.Euler();
			
			const moonGroup = new THREE.Group();
			moonGroup.rotation.set = new THREE.Euler();
			
			const moonMesh = new THREE.Mesh(geometry, moonMaterial);
			moonMesh.position.set(moonOrbitRadius, 0, 0);
			moonMesh.rotation.y = Math.PI;
			moonMesh.scale.setScalar(moonRadius);
			moonMesh.castShadow = true;
			moonMesh.receiveShadow = true;
			moonGroup.add(moonMesh);
			
			// Moon orbit
			const moonOrbit = new THREE.Line( orbitGeometry, orbitMaterial );
			moonOrbit.rotation.x = Math.PI / 2;
			moonOrbit.scale.setScalar(moonOrbitRadius);
			moonGroup.add(moonOrbit);
			
			moonMainGroup.add(moonGroup);
						
			moonMainGroup.position.set(earthOrbitRadius, 0, 0);
			moonMainGroup.rotation.z = moon_tiltSlider.value * 5.14 * Math.PI / 180;
			
			scene.add(moonMainGroup);
			
			// Lighting
			const light = new THREE.DirectionalLight( 0xffffff, 2 );
			light.position.set( 0, 0, 0 );
			light.target = earthMesh;
			light.castShadow = true;
			scene.add(light);

			// Controls
			earth_thetaSlider.oninput = function() {
				const theta = this.value * Math.PI / 180;
				earthGroup.rotation.y = theta;
				moonMainGroup.position.set(earthOrbitRadius * Math.cos(theta), 0, - earthOrbitRadius * Math.sin(theta));
			}
			moon_thetaSlider.oninput = function() {
				moonGroup.rotation.y = this.value * Math.PI / 180;
			}
			moon_tiltSlider.oninput = function() {
				moonMainGroup.rotation.z = this.value * 5.14 * Math.PI / 180;
			}
			
			const animate = function () {
				renderer.render( scene, camera );
				requestAnimationFrame( animate );
			};

			animate();
		</script>
	</body>
</html>
